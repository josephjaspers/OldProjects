/*
 * BC_Tensor_Base.h
 *
 *  Created on: Dec 12, 2017
 *      Author: joseph
 */

#ifndef TENSOR_LV4_MATH_SIMPLE_H_
#define TENSOR_LV4_MATH_SIMPLE_H_

#include "Tensor_Lv3_ArrayType_Utility.h"
#include "Tensor_Lv3_ExpressionType_Utility.h"

template<
class T,										//The internal array type
class derived,									//The derived class
class math_lib,					    		    //Math_library
class inner_shape,
class outer_shape = typename DEFAULT_LD<inner_shape>::type
>
struct Tensor_Base :

		BC_MTF::IF_ELSE<Tensor_FunctorType<T>::supports_utility_functions,								//if supports_utility_functions
		BC_Tensor_Utility_Array<T, derived, math_lib, inner_shape, outer_shape>,						//		inherit from Utility_Array
		BC_Tensor_Utility_Expression<T, derived, math_lib, inner_shape, outer_shape>>::type				//else
																										//		inherit from Utility_expression
	{
	using absolute_base_type   = Tensor_Base<T, derived, math_lib, inner_shape>; 	//Matching type with outer_shape adjustment
	using absolute_type        = typename Tensor_Base<T, derived, math_lib, inner_shape>::this_type; //gets the derived class with default outer_shape
	using my_type		   = Tensor_Base<T, derived, math_lib, inner_shape, outer_shape>;
	using this_type    = derived;
	using functor_type = typename  Tensor_Type<T, derived, math_lib, Tensor_Shape<inner_shape, outer_shape>>::functor_type;

	using parent_class =
			typename BC_MTF::IF_ELSE<Tensor_FunctorType<T>::supports_utility_functions,
			BC_Tensor_Utility_Array<T, derived, math_lib, inner_shape, outer_shape>,
			BC_Tensor_Utility_Expression<T, derived, math_lib, inner_shape, outer_shape>>::type;

	using grandparent_class = typename parent_class::grandparent_class;

	/*
	 * What's happening?
	 *
	 * 	Each of these pointwise operator accepts a Tensor_Base<U (anytype), deriv (any derived), math_lib(same), dimensions...(same)>
	 *  and returns a derived class of type binary_expression<T, math_function, functor_type, param::functor_type>.
	 *
	 *  The replace_front metatemplate function is called to assist in the conversion from type T to binary_expression.
	 *  IE Vector<T, 100> will be replaced to Vector<bin_expr, 100>.
	 */


	template<class... params> explicit Tensor_Base(const params...  p) : parent_class(p...) {}
	Tensor_Base() = default;
	template<class U, class deriv>
	Tensor_Base(const typename BC_Substitute_Type::Identity<expression<U, deriv>, this_type>::type& tensor) = delete;

//pointwise methods

	template<class U, class deriv, class ld>
	typename BC_Substitute_Type::Identity<binary_expression<T, BC::add, functor_type, typename Tensor_Base<U, deriv, math_lib, inner_shape, ld>::functor_type>, this_type>::type  //return object
	operator + (const Tensor_Base<U, deriv, math_lib, inner_shape, ld>& rv) {
		return typename BC_Substitute_Type::Identity<binary_expression<T, BC::add, functor_type, typename Tensor_Base<U, deriv, math_lib, inner_shape, ld>::functor_type>, this_type>::type(this->data(), rv.data());
	}

	template<class U, class deriv, class ld>
	typename BC_Substitute_Type::Identity<binary_expression<T, BC::sub, functor_type, typename Tensor_Base<U, deriv, math_lib, inner_shape, ld>::functor_type>, this_type>::type  //return object
	operator - (const Tensor_Base<U, deriv, math_lib, inner_shape, ld>& rv) {
		return typename BC_Substitute_Type::Identity<binary_expression<T, BC::sub, functor_type, typename Tensor_Base<U, deriv, math_lib, inner_shape, ld>::functor_type>, this_type>::type(this->data(), rv.data());
	}

	template<class U, class deriv, class ld>
	typename BC_Substitute_Type::Identity<binary_expression<T, BC::div, functor_type, typename Tensor_Base<U, deriv, math_lib, inner_shape, ld>::functor_type>, this_type>::type  //return object
	operator / (const Tensor_Base<U, deriv, math_lib, inner_shape, ld>& rv) {
		return typename BC_Substitute_Type::Identity<binary_expression<T, BC::div, functor_type, typename Tensor_Base<U, deriv, math_lib, inner_shape, ld>::functor_type>, this_type>::type(this->data(), rv.data());
	}

	template<class U, class deriv, class ld>
	typename BC_Substitute_Type::Identity<binary_expression<T, BC::mul, functor_type, typename Tensor_Base<U, deriv, math_lib, inner_shape, ld>::functor_type>, this_type>::type  //return object
	operator % (const Tensor_Base<U, deriv, math_lib, inner_shape, ld>& rv) {
		return typename BC_Substitute_Type::Identity<binary_expression<T, BC::mul, functor_type, typename Tensor_Base<U, deriv, math_lib, inner_shape, ld>::functor_type>, this_type>::type(this->data(), rv.data());
	}

//Scalar methods

	template<class U, class deriv, class ld>
	typename BC_Substitute_Type::Identity<binary_expression_scalar_R<T, BC::add, functor_type, typename Tensor_Base<U, deriv, math_lib, Inner_Shape<1>, ld>::functor_type>, this_type>::type  //return object
	operator + (const Tensor_Base<U, deriv, math_lib, Inner_Shape<1>, ld>& rv) {
		return typename BC_Substitute_Type::Identity<binary_expression_scalar_R<T, BC::add, functor_type, typename Tensor_Base<U, deriv, math_lib, Inner_Shape<1>, ld>::functor_type>, this_type>::type(this->data(), rv.data());
	}

	template<class U, class deriv, class ld>
	typename BC_Substitute_Type::Identity<binary_expression_scalar_R<T, BC::sub, functor_type, typename Tensor_Base<U, deriv, math_lib, Inner_Shape<1>, ld>::functor_type>, this_type>::type  //return object
	operator - (const Tensor_Base<U, deriv, math_lib, Inner_Shape<1>, ld>& rv) {
		return typename BC_Substitute_Type::Identity<binary_expression_scalar_R<T, BC::sub, functor_type, typename Tensor_Base<U, deriv, math_lib, Inner_Shape<1>, ld>::functor_type>, this_type>::type(this->data(), rv.data());
	}

	template<class U, class deriv, class ld>
	typename BC_Substitute_Type::Identity<binary_expression_scalar_R<T, BC::div, functor_type, typename Tensor_Base<U, deriv, math_lib, Inner_Shape<1>, ld>::functor_type>, this_type>::type  //return object
	operator / (const Tensor_Base<U, deriv, math_lib, Inner_Shape<1>, ld>& rv) {
		return typename BC_Substitute_Type::Identity<binary_expression_scalar_R<T, BC::div, functor_type, typename Tensor_Base<U, deriv, math_lib, Inner_Shape<1>, ld>::functor_type>, this_type>::type(this->data(), rv.data());
	}

	template<class U, class deriv, class ld>
	typename BC_Substitute_Type::Identity<binary_expression_scalar_R<T, BC::mul, functor_type, typename Tensor_Base<U, deriv, math_lib, Inner_Shape<1>, ld>::functor_type>, this_type>::type  //return object
	operator % (const Tensor_Base<U, deriv, math_lib, Inner_Shape<1>, ld>& rv) {
		return typename BC_Substitute_Type::Identity<binary_expression_scalar_R<T, BC::mul, functor_type, typename Tensor_Base<U, deriv, math_lib, Inner_Shape<1>, ld>::functor_type>, this_type>::type(this->data(), rv.data());
	}
};
#endif /* TENSOR_LV4_MATH_SIMPLE_H_ */
