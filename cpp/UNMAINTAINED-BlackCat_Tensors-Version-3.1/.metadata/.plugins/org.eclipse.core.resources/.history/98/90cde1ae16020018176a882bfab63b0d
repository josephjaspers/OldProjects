/*
 * Tensor_Lv2_Core_impl.h
 *
 *  Created on: Jan 2, 2018
 *      Author: joseph
 */

#ifndef TENSOR_LV2_CORE_IMPL_H_
#define TENSOR_LV2_CORE_IMPL_H_

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <sstream>

namespace BC {

template<class T, class deriv, class Mathlib, bool Utility_Function_Supported>
struct Tensor_Utility {};



template<class scalar_type, class deriv, class MATHLIB>
struct Tensor_Utility<scalar_type, deriv, MATHLIB, true> {

/*
 *  Tensor_Base specialization (for primary tensors -- we enable these utility methods)
 */

	deriv& asDerived() {
		return static_cast<deriv&>(*this);
	}
	const deriv& asDerived() const {
		return static_cast<const deriv&>(*this);
	}

	void randomize(scalar_type lb, scalar_type ub) {
		MATHLIB::randomize(asDerived().data(), lb, ub, asDerived().size());
	}
	void fill(scalar_type value) {
		MATHLIB::fill(asDerived().data(), value, asDerived().size());
	}
	void zero() {
		MATHLIB::zero(asDerived().data(), asDerived().size());
	}
	void zeros() {
		MATHLIB::zero(asDerived().data(), asDerived().size());
	}
	void print() const {
		MATHLIB::print(asDerived().data(), asDerived().InnerShape(), asDerived().rank(), 8);
	}
	void print(int precision) const {
		MATHLIB::print(asDerived().data(), asDerived().InnerShape(), asDerived().order(), precision);
	}


	void reset(std::vector<int> dimensions = std::vector<int>(0)) {
		this->asDerived().resetShape(dimensions); //dimensions auto converts to type  shape_packet<_generic>
		MATHLIB::destroy(asDerived().data());
		MATHLIB::initialize(asDerived().data(), asDerived().size());
	}

	void write(std::ofstream& os) {

		scalar_type* data = new scalar_type[asDerived().size()];
		MATHLIB::DeviceToHost(data, asDerived().data(), asDerived().size());
		os << asDerived().rank() << ',';
		for (int i = 0; i < asDerived().rank(); ++i) {
			os << asDerived().dimension(i) << ',';
		}
		for (int i = 0; i < asDerived().size() - 1; ++i) {
			os << asDerived().data()[i] << ',';
		}
		os << asDerived().data()[asDerived().size() - 1];
		os << '\n';
	}
	void read(std::ifstream& is, bool read_dimensions = true, bool overrideDimensions = true) {
		std::string row;
		std::getline(is, row, '\n');
		std::string tmp;
		std::stringstream stream(row);
		std::stringstream col(row);


		std::cout << row << std::endl;

		if (read_dimensions) {
			int order;
			std::getline(stream, tmp, ',');
			col.str(tmp);

			col >> order;

			std::vector<int> sh(order);
			for (int i = 0; i < order; ++i) {
			       stream >> sh[i];
				if (stream.peek() == ',')
			           stream.ignore();
			    }
			}

			if (overrideDimensions)
				this->asDerived().reset(sh);
		}

		scalar_type* ary = new scalar_type[this->asDerived().size()];
		for (int i = 0; i < this->asDerived().size(); ++i) {
			std::getline(stream, tmp, ',');
			col.str(tmp);
			col >> ary[i];
		}







	}

};

}



#endif /* TENSOR_LV2_CORE_IMPL_H_ */
