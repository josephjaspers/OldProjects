MethodList for BlackCatTensors3.3

-------UtilityMethods-------
defined in: BC_Core/Implementation_Core/Tensor_Utility.h

void print() const; 											//Formats the internal data and prints, available only to non-expression tensors
void print(int precision) const;								//Formats the internal data and prints, with specified precision
void randomize(T lowerbound, T upperbound)						//Randomizes the data in range
void fill(T value)												//Fill contents with given value
void zero();													//zero the tensor
void zeros();													//zero the tensor
void reset(std::vector<int> dimensions = std::vector<int>(0));  //resizes the Tensor and reallocates the memory.

void write(std::ofstream& os);									//writes contents to a single line of a file(formatted as CSV)
void read(std::ifstream& is, bool read_dimensions = true, bool overrideDimensions = true); 	//reads a line from a CSV if you are reading from a CSV NOT 													  generated from this library use: myTensor.read(ifstream&, false); 

**Writes explained: Writes the order, than dimensions of a the tensors, IE I 3x4 matrix will format as.... 2, 3, 4, contents, (2 = order, 3 = rows, 4 = cols and then it will write the contents)
**Read   explained: If you use read(std::ifstream&, default_bool, default_bool) it will assume the file was written originally by this class,
					to read the contents straight from a CSV (not generated by this class) use: myTensor.read(std::ifstream&, false)
					to read the file but do not rescale tensor use: myTensor.read(std::ifstream&, false, true);
					
**Most of the UtilityMethods are only available to non-expression tensors.

--------Shape Information--------
defined in: BC_Core/Implementation_Core/Shape.h


void printDetails() const;				//prints details about tensors --- used for debugging 
int rank() const;						//give rank of tensor
int size() const;						//size of tensor
int rows() const;				
int cols() const;
int dimension(int i) const;				//dimension of tensor at index[i] --> support for higher order tensor is being developed 
void printDimensions() const;			//print dimensions: formated as. [rows][cols][etc]
void printLDDimensions() const;			//print leadingDimensions, same format

int LD_rows() const;
int LD_cols() const;
int LDdimension(int i);
void resetShape(std::vector<int> dimensions);			//resizes the shape but does not reallocated memory (DOES NOT CHECK FOR CORRECTNESS)

---------Operators-------------
defined in: BC_Core/Implementation_Core/Tensor_Operations_impl.h

All pointwise methods return the type of the class left of the operand unless it is a Scalar by Tensor or Tensor by Scalar operation, at which it returns the type of Tensor)

typename operator * (const Tensor& t)		//Scalar product if by Scalar, else dotproduct
typename operator + (const Tensor& t)		//pointwise addition
typename operator - (const Tensor& t)		//pointwise subtraction
typename operator / (const Tensor& t)		//pointwise division
typename oerator % (const Tensor& t)		//pointwise multiplication
typename operator ** (const Tensor& t)		//pointwise multiplication (alternate)

typename& operator += (const Tensor& t)		//add to 		(instant evaluation)
typename& operator -= (const Tensor& t)		//subtract to 	(instant evaluation)
typename& operator /= (const Tensor& t)		//divide to 	(instant evaluation)
typename& operator %= (const Tensor& t)		//multiply to 	(instant evaluation) 

typename& operator =  (const Tensor& t)		//copy operator							//This is not available to expresion tensors.
typename  operator == (const Tensor& t)		//delayed evaluation copy operator

typename unExpr (T functor_obj)
typename biExpr (T functor_obj, const Tensor& t) 

--------------Others------------------
defined  in: BC_Core/Vector.h or BC_Core/Matrix.h

const typename operator t () const;		//returns a transpose expression. //defined in Vector.h and Matrix.h
typename operator [] (int i);			//Returns the next access. IE Matrix[0] //returns first column, Matrix[1][1] return second columns second scalar
T* data();					//returns the internal array (or the intenral functor if it is an expression type)

*** if you want to iterate through a Vector/Matrix...

for (int i = 0; i < ary.size(); ++i) 
	ary.data()[i] = //do stuff
	
	
-------General Notes---------
This class only supports primitive data types and strings. 
If you want to use a number class 
go to: BC_Core/MetaTemplateFunctions/Simple.h and the specialization to isPrimitive<T> 

---------------------------------------

You may pass a function object to unExpr (unary expression) or biExpr (binary expression)
to create an expression that becomes part of the delayed evaluation set of a function.
BlackCat_Tensors_Functions/Functions/BlackCat_TensorFunctions.cu has a set of functions for NeuralNetworks that illustrate how to create your own lazy evaluation function. 

Here's an example of how it would work:

struct unExprExample_Pow2 {

	template<class T> __attribute__((always_inline))
	auto operator (T t) {
		return pow(t, 2);	
	}
};
struct biExprExample_Pow2 {

	template<class T, class U> __attribute__((always_inline))
	auto operator (T t, U u) {
		return pow(t, u);	
	}
};

Vector<float> myVec(10); 
Vector<float> myVecToAssign(10);

//creates a lazy expression and than assigns it 
myVecToAssign = myVec.unExpr(unExprExample_Pow2());

----------Notes on optimization---------

All variants of dotproduct are well accounted for...
Functions like:

y = a * A * (b * B)

will register that you are attempting to do a dotproduct with 2 scalars. This will result in a single dgemm call before assigning to y (2 method calls)

Functions that are purely pointwise will result in a single function call: 
y = a + b / c ** d; //results in a single for loop.

---------------------------The inheritance hierachy (how the does it work?)-----------------------------


----------------Diagram for genuine (non-expression) tensors---------------------

Tensor_Operations_impl
          | 
 Tensor_Operations	Shape	 Tensor_Utility	
	      |		      |            |
	      -------     |    ---------		
		        |     |    |	
                 TensorBase
                      |
 		     ------------------
		     |        |       | 
		    Scalar  Vector   Matrix


----------------Diagram for pointwise expression tensors---------------------

Tensor_Operations_impl
          | 
 Tensor_Operations	    	 Tensor_Utility	------->Inherits from a different specialization of tensor_utility (more limited)
	      |		                   |
	      -------          ---------		
		        |          |	
                 TensorBase ----------------------->no longer inherits from Shape, contains a reference to a Shape object
                      |
 		     ------------------
		     |        |       | 
		    Scalar  Vector   Matrix


Following classes are specialized: 
Tensor_Utility (two specializations)
Tensor_Base (three specializations)
 

Tensor_Operations_impl
          | 
  Tensor_Operations	Shape	Tensor_Utility_A OR Tensor_Utility_B
	  |		  |           |
	  ------------    |   ---------		
		     |    |   |	
      TensorBase_A OR TensorBase_B OR TensorBase_C
                          |
 		  |----------------|
		  |       |        | 
		Scalar  Vector   Matrix

--> TensorBase_A //specialized for pointwise operations
--> TensorBase_B //specialized for non-pointwise operations (transpose/dotproduct)
--> TensorBase_C //specialized for simple Tensors 

--> Tensor_Utility_A //specialized for tensors
--> Tensor_Utility_B //specialized for expressions 





