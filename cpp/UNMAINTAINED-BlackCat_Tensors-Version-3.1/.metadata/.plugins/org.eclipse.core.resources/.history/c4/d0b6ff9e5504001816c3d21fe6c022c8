#ifndef BLACKCAT_TENSOR_FUNCTIONS
#define BLACKCAT_TENSOR_FUNCTIONS
namespace BC {

#ifdef __CUDACC__
#define __BC_gcpu__ __host__ __device__
#define BLACKCAT_GPU_ENABLED
#else
#define __BC_gcpu__
#endif

	namespace NN_Functions {

		struct Sigmoid {

			template<class T>
			__BC_gcpu__ T operator () (T t) const {
				static constexpr T e = 2.71828;

				return 1 / (1 + std::pow(e, - t));
			}
		};
		struct SigmoidAssign {

			template<class T>
			__BC_gcpu__ T operator () (T& t) const {
				static constexpr T e = 2.71828;

				return t = 1 / (1 + std::pow(e, - t));
			}
		};
		struct CachedSigmoidDeriv {

			template<class T>
			__BC_gcpu__ T operator () (T t) const {
				return t * (1 - t);
			}
		};
		struct CachedSigmoidDerivAssign {

			template<class T>
			__BC_gcpu__ T operator () (T& t) const {
				return t *= (1 - t);
			}
		};

		struct Tanh {

			template<class T>
			__BC_gcpu__ T operator () (T t) const {
				static constexpr double e = 2.71828;

				return (powf(e, t) - powf(e, -t)) /
					   (powf(e, t) + powf(e, -t));
			}
		};
		struct TanhAssign {

			template<class T>
			__BC_gcpu__ T operator () (T& t) const {
				static constexpr T e = 2.71828;

				return t = (powf(e, t) - powf(e, -t)) /
					       (powf(e, t) + powf(e, -t));
			}
		};
		struct CachedTanhDeriv {

			template<class T>
			__BC_gcpu__ T operator () (T t) const {
				return 1 - powf(t, 2);
			}
		};
		struct CachedTanhDerivAssign {

			template<class T>

			__BC_gcpu__ T operator () (T& t) const {
				static constexpr T e = 2.71828;

				return t = 1 - powf(t, 2);
			}
		};

		template<template<class,class> class tensor, class T, class ml>
		void sigmoid(tensor<T, ml>& x) {
			return x.unFunc(SigmoidAssign());
		}
		template<template<class,class> class tensor, class T, class ml>
		void sigmoid(tensor<T, ml>&& x) {
			return x.unFunc(Sigmoid());
		}
		template<template<class,class> class tensor, class T, class ml>
		void sigmoidDeriv(tensor<T, ml>& x) {
			return x.unFunc(CachedSigmoidDerivAssign());
		}
		template<template<class,class> class tensor, class T, class ml>
		void sigmoidDeriv(tensor<T, ml>&& x) {
			return x.unFunc(CachedSigmoidDeriv());
		}

	}

	namespace NN_Abreviated_Functions {
		using namespace NN_Functions;
		template<template<class,class> class tensor, class T, class ml>
		void g(tensor<T, ml>& x) {
			return x.unFunc(SigmoidAssign());
		}
		template<template<class,class> class tensor, class T, class ml>
		void g(tensor<T, ml>&& x) {
			return x.unFunc(Sigmoid());
		}
		template<template<class,class> class tensor, class T, class ml>
		void gd(tensor<T, ml>& x) {
			return x.unFunc(CachedSigmoidDerivAssign());
		}
		template<template<class,class> class tensor, class T, class ml>
		void gd(tensor<T, ml>&& x) {
			return x.unFunc(CachedSigmoidDeriv());
		}

	}

}
#endif
