/*
 * BC_Tensor_Cube.h
 *
 *  Created on: Dec 18, 2017
 *      Author: joseph
 */

#ifndef BC_TENSOR_CUBE_H_
#define BC_TENSOR_CUBE_H_



#include "../BlackCat_Global_Unifier.h"
#include "BC_Tensor_Vector.h"

template<class T, int row, int col, int depth, class lib, //default = CPU,
		class LD // default = typename DEFAULT_LD<Inner_Shape<row>>::type
>
class Cube : public Tensor_Base<T, Cube<T, row,col, depth, lib>, lib, Inner_Shape<row, col, depth>, typename DEFAULT_LD<Inner_Shape<row, col, depth>>::type> {

	using functor_type = typename Tensor_FunctorType<T>::type;
	using parent_class = Tensor_Base<T, Cube<T, row, col, depth, lib>, lib, Inner_Shape<row, col>, typename DEFAULT_LD<Inner_Shape<row, col>>::type>;
	using grandparent_class = typename parent_class::grandparent_class;
	using this_type = Cube<T, row, col, depth, lib>;

public:

	using parent_class::operator=;
	using parent_class::parent_class;

	Cube() = default;
	template<class ... params> 	Cube(params ... p) : parent_class(p...) {}

	template<class U> 		  	Cube(const Cube<U, row, col, depth, lib>&  vec) : parent_class() { (*this) = vec; }
	template<class U>		  	Cube(      Cube<U, row, col, depth, lib>&& vec) : parent_class() { (*this) = vec; }

	template<class U> Vector<T, row, lib>& operator =(const Cube<U, row, col, depth, lib>& v) {
		static_assert(grandparent_class::ASSIGNABLE, "Matrix<T, row, col, lib> of type T is non assignable (use Eval() to evaluate expression-tensors)");

		this->size() > OPENMP_SINGLE_THREAD_THRESHHOLD ?
			lib::copy(this->data(), v.data(), this->size()):
			lib::copy_single_thread(this->data(), v.data(), this->size());

		return *this;
	}

};


#endif /* BC_TENSOR_CUBE_H_ */
