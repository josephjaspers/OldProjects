
namespace BC {

#ifdef __CUDACC__
#define __BC_gcpu__ __host__ __device__
#define BLACKCAT_GPU_ENABLED
#else
#define __BC_gcpu__
#endif

	namespace NN_Functions {
		static constexpr double e = 2.71828;

		struct Sigmoid {

			template<class T>
			__BC_gcpu__ T operator () (T t) const {
				return 1 / (1 + std::pow(e, - t));
			}
		};
		struct SigmoidAssign {

			template<class T>
			__BC_gcpu__ T operator () (T& t) const {
				return t = 1 / (1 + std::pow(e, - t));
			}
		};
		struct CachedSigmoidDeriv {

			template<class T>
			__BC_gcpu__ T operator () (T t) const {
				return t * (1 - t);
			}
		};
		struct CachedSigmoidDerivAssign {

			template<class T>
			__BC_gcpu__ T operator () (T& t) const {
				return t *= (1 - t);
			}
		};

		struct Tanh {
			static constexpr double e = 2.71828;

			template<class T>
			__BC_gcpu__ T operator () (T t) const {
				return 1 / (1 + std::pow(e, - t));
			}
		};
		struct TanhAssign {
			static constexpr double e = 2.71828;

			template<class T>
			__BC_gcpu__ T operator () (T& t) const {
				return t = 1 / (1 + std::pow(e, - t));
			}
		};
		struct CachedTanhDeriv {

			template<class T>
			__BC_gcpu__ T operator () (T t) const {
				return t * (1 - t);
			}
		};
		struct CachedTanhDerivAssign

			template<class T>
			__BC_gcpu__ T operator () (T& t) const {
				return t *= (1 - t);
			}
		};

		template<template<class,class> class tensor, class T, class ml>
		void sigmoid(tensor<T, ml>& x) {
			return x.unFunc(SigmoidAssign());
		}
		template<template<class,class> class tensor, class T, class ml>
		void sigmoid(tensor<T, ml>&& x) {
			return x.unFunc(Sigmoid());
		}
		template<template<class,class> class tensor, class T, class ml>
		void sigmoidDeriv(tensor<T, ml>& x) {
			return x.unFunc(CachedSigmoidDerivAssign());
		}
		template<template<class,class> class tensor, class T, class ml>
		void sigmoidDeriv(tensor<T, ml>&& x) {
			return x.unFunc(CachedSigmoidDeriv());
		}

	}

	namespace NN_Abreviated_Functions {
		using namespace NN_Functions;
		template<template<class,class> class tensor, class T, class ml>
		void g(tensor<T, ml>& x) {
			return x.unFunc(SigmoidAssign());
		}
		template<template<class,class> class tensor, class T, class ml>
		void g(tensor<T, ml>&& x) {
			return x.unFunc(Sigmoid());
		}
		template<template<class,class> class tensor, class T, class ml>
		void gd(tensor<T, ml>& x) {
			return x.unFunc(CachedSigmoidDerivAssign());
		}
		template<template<class,class> class tensor, class T, class ml>
		void gd(tensor<T, ml>&& x) {
			return x.unFunc(CachedSigmoidDeriv());
		}

	}












}
